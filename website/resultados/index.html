<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Resultados | Torneio de Robótica de Gravataí 2025</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        body {
            background: #f5f6f7;
        }

        header {
            padding-top: 1.25rem;
        }

        .score-card {
            border-radius: 1.2rem;
            padding: 2.5rem 1.25rem 2rem;
            color: #fff;
            position: relative;
            overflow: hidden;
        }

        .score-card.red {
            background: #cf2e40;
        }

        .score-card.blue {
            background: #0066f3;
        }

        .score-value {
            font-size: 5rem;
            font-weight: 700;
            line-height: 0.9;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            font-size: 1rem;
            margin: .35rem 0;
        }

        .metric-row span.value {
            font-weight: 600;
            letter-spacing: .5px;
        }

        .divider-col {
            background: linear-gradient(180deg, #ffffff20, #ffffff05);
            width: 2px;
            margin: 0 auto;
        }

        .team-name {
            font-size: 2.2rem;
            font-weight: 600;
        }

        .badge-year {
            font-size: .9rem;
            letter-spacing: .5px;
        }

        .select-wrapper {
            max-width: 620px;
            margin: 0 auto;
        }

        .loading {
            animation: pulse 1.2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: .4;
            }

            50% {
                opacity: 1;
            }
        }

        footer {
            font-size: .75rem;
            color: #666;
            margin-top: 3rem;
        }

        .star {
            color: #ffd24d;
            font-size: .85rem;
            margin-left: .25rem;
        }

        .metric-row .label {
            white-space: nowrap;
            padding-right: .5rem;
        }

        @media (max-width: 992px) {
            .score-value {
                font-size: 3.75rem;
            }

            .team-name {
                font-size: 1.6rem;
            }

            .score-card {
                padding: 2rem 1rem 1.5rem;
            }
        }
    </style>
</head>

<body>
    <header class="text-center mb-4">
        <div class="container">
            <h1 class="h3 mt-3 mb-3">Eliminatórias - Torneio de Robótica de Gravataí 2025</h1>
            <div class="select-wrapper d-flex gap-2 flex-wrap align-items-center">
                <select id="selectJogo" class="form-select flex-grow-1" disabled>
                    <option>Carregando confrontos...</option>
                </select>
                <button id="btnBuscar" class="btn btn-primary" disabled>Buscar</button>
            </div>
            <p id="statusMsg" class="text-muted small mt-2"></p>
        </div>
    </header>
    <main class="container">
        <div id="painelResultados" class="row g-4 align-items-stretch">
            <div class="col-12 col-lg-6">
                <div class="score-card red h-100" id="cardVermelho">
                    <div class="team-name mb-2" id="nomeEquipeVermelha">Equipe Vermelha</div>
                    <div class="score-value mb-3" id="pontosVermelho">0</div>
                    <div id="metricsVermelho"></div>
                </div>
            </div>
            <div class="col-12 col-lg-6">
                <div class="score-card blue h-100" id="cardAzul">
                    <div class="team-name mb-2" id="nomeEquipeAzul">Equipe Azul</div>
                    <div class="score-value mb-3" id="pontosAzul">0</div>
                    <div id="metricsAzul"></div>
                </div>
            </div>
        </div>
    </main>

    <script type="module">
        import { carregarSheetData } from "../sheets-to-website/sheetUtils.js";

        // URL da aba de eliminatórias (envios / estrutura operacional)
        const URL_PLANILHA_ELIM = "https://docs.google.com/spreadsheets/d/1Dj8gcfgJWh5a1rL2cCuoEopNH9XobLSv5wWIKrNVeo8/edit?gid=915910798#gid=915910798";
        // URL da aba de resultados oficiais (consolidados) fornecida
        const URL_PLANILHA_RESULTADOS = "https://docs.google.com/spreadsheets/d/1Dj8gcfgJWh5a1rL2cCuoEopNH9XobLSv5wWIKrNVeo8/edit?gid=314140830#gid=314140830";

        // Mapeamento de colunas (eliminatórias)
        const COLUMN_MAPPING_ELIM = {
            numeroJogo: 'Numero do jogo',
            alianca: 'Alianca',
            equipe1: 'Equipe 1',
            equipe2: 'Equipe 2',
            pontosN1Equipe1: 'pontosN1equipe1',
            pontosN2Equipe1: 'pontosN2equipe1',
            pontosN3Equipe1: 'pontosN3equipe1',
            pontosMovEquipe1: 'pontosMovEquipe1',
            pontosN1Equipe2: 'pontosN1equipe2',
            pontosN2Equipe2: 'pontosN2equipe2',
            pontosN3Equipe2: 'pontosN3equipe2',
            pontosMovEquipe2: 'pontosMovEquipe2',
            pontosAlianca: 'Pontos Alianca'
        };

        // Função util para normalizar chaves dinâmicas da planilha (ignora acentos e case)
        function normalizarChave(str) {
            return (str || '').normalize('NFD').replace(/[^\w\s]/g, '').replace(/\s+/g, ' ').trim().toLowerCase();
        }

        // Tenta encontrar o valor de uma coluna mesmo que cabeçalho varie (ex: Alianca/Aliança, Numero do jogo/Número do jogo)
        function getValorFlex(row, alvo) {
            const alvoNorm = normalizarChave(alvo);
            for (const k of Object.keys(row)) {
                if (normalizarChave(k) === alvoNorm) return row[k];
            }
            return undefined;
        }

        const selectJogo = document.getElementById('selectJogo');
        const btnBuscar = document.getElementById('btnBuscar');
        const statusMsg = document.getElementById('statusMsg');

        let dadosElim = [];
        let dadosOficiais = [];
        let matchesElim = []; // [{idMatch:'..', aliancaA:{}, aliancaB:{}, numeroJogo:'..', oficial:boolean}]

        // Renderização das métricas de uma aliança (duas equipes)
        function renderAllianceMetrics(containerId, aliancaObj) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            if (!aliancaObj) {
                container.innerHTML = '<div class="text-light opacity-75">Aguardando adversário...</div>';
                return;
            }
            const { nomeAlianca, equipe1, equipe2 } = aliancaObj;
            const header = document.createElement('div');
            header.className = 'mb-2 fw-semibold';
            header.textContent = nomeAlianca;
            container.appendChild(header);
            const lines = [
                { grupo: 'Equipe 1', dados: equipe1 },
                { grupo: 'Equipe 2', dados: equipe2 }
            ];
            lines.forEach(l => {
                const title = document.createElement('div');
                title.className = 'mt-2 small text-uppercase fw-semibold';
                title.textContent = l.grupo + ': ' + (l.dados.nome || '');
                container.appendChild(title);
                const tbl = document.createElement('div');
                tbl.className = 'mb-1';
                ['N1', 'N2', 'N3', 'Mov', 'Total'].forEach(k => {
                    const row = document.createElement('div');
                    row.className = 'metric-row';
                    const keyMap = { N1: 'pN1', N2: 'pN2', N3: 'pN3', Mov: 'pMov', Total: 'total' };
                    row.innerHTML = `<span class="label">${k}:</span><span class="value">${(l.dados[keyMap[k]] ?? 0).toString().padStart(2, '0')}</span>`;
                    tbl.appendChild(row);
                });
                container.appendChild(tbl);
            });
            const totalAlianca = document.createElement('div');
            totalAlianca.className = 'metric-row mt-2';
            totalAlianca.innerHTML = '<span class="label">Pontos Aliança:</span><span class="value fw-semibold">' + (aliancaObj.pontosAlianca || 0) + '</span>';
            container.appendChild(totalAlianca);
        }

        async function carregarJogosElim() {
            statusMsg.textContent = 'Carregando eliminatórias...';
            try {
                dadosElim = await carregarSheetData(URL_PLANILHA_ELIM);
                try { dadosOficiais = await carregarSheetData(URL_PLANILHA_RESULTADOS); } catch { dadosOficiais = []; }
                const linhasProcessadas = dadosElim.map((row, idx) => {
                    const numero = getValorFlex(row, COLUMN_MAPPING_ELIM.numeroJogo) || row['numeroJogo'] || row['Número do jogo'];
                    const aliancaNome = getValorFlex(row, COLUMN_MAPPING_ELIM.alianca);
                    return { ...row, __idx: idx, _numeroJogoNorm: numero, _aliancaNomeNorm: aliancaNome };
                });
                const linhasValidas = linhasProcessadas.filter(l => {
                    const nome = (l._aliancaNomeNorm || '').toLowerCase();
                    return nome && !nome.includes('desempate') && !nome.includes(' ou ');
                });
                const agrupadoPorNumero = {};
                linhasValidas.forEach(l => { const n = l._numeroJogoNorm; if (!n) return; (agrupadoPorNumero[n] || (agrupadoPorNumero[n] = [])).push(l); });
                const confrontosDiretos = [];
                Object.keys(agrupadoPorNumero).forEach(num => {
                    const map = {}; agrupadoPorNumero[num].forEach(r => { map[r._aliancaNomeNorm] = r; });
                    const lista = Object.values(map); if (lista.length === 2) confrontosDiretos.push({ numeroJogo: num, a: lista[0], b: lista[1] });
                });
                if (confrontosDiretos.length) {
                    matchesElim = confrontosDiretos.sort((x, y) => Number(x.numeroJogo) - Number(y.numeroJogo)).map(c => ({
                        idMatch: 'J' + c.numeroJogo, numeroJogo: c.numeroJogo, aliancaA: buildAllianceFromRegistro(c.a), aliancaB: buildAllianceFromRegistro(c.b)
                    }));
                } else {
                    const ultima = {}; linhasValidas.forEach(l => { ultima[l._aliancaNomeNorm] = l; });
                    const seeds = Object.values(ultima).map(r => { const m = (r._aliancaNomeNorm || '').match(/(\d+)/); return { seed: m ? Number(m[1]) : 99, registro: r }; }).sort((a, b) => a.seed - b.seed);
                    const pares = []; for (let i = 0, j = seeds.length - 1; i < j; i++, j--) pares.push([seeds[i], seeds[j]]);
                    matchesElim = pares.map(p => ({ idMatch: p[0].seed + 'x' + p[1].seed, numeroJogo: '', aliancaA: buildAllianceFromRegistro(p[0].registro), aliancaB: buildAllianceFromRegistro(p[1].registro) }));
                }
                aplicarResultadosOficiais();
                selectJogo.innerHTML = '<option value="">Selecione o confronto</option>';
                matchesElim.forEach(m => {
                    const opt = document.createElement('option');
                    const prefix = m.oficial ? '⭐ ' : '';
                    opt.value = m.idMatch;
                    opt.textContent = m.numeroJogo ? `${prefix}${m.idMatch} (Jogo ${m.numeroJogo}): ${m.aliancaA.nomeAlianca} x ${m.aliancaB.nomeAlianca}` : `${prefix}${m.idMatch}: ${m.aliancaA.nomeAlianca} x ${m.aliancaB.nomeAlianca}`;
                    selectJogo.appendChild(opt);
                });
                selectJogo.disabled = false; btnBuscar.disabled = false;
                statusMsg.textContent = matchesElim.length ? '' : 'Nenhum confronto encontrado.';
            } catch (err) { statusMsg.textContent = 'Erro ao carregar eliminatórias: ' + err; }
        }
        function buildAllianceFromRegistro(linha) {
            if (!linha) return null;
            // Log de chaves (apenas primeira vez para debug)
            if (!window.__logChavesOnce) {
                window.__logChavesOnce = true;
                console.group('%c[ELIM] Chaves da linha (debug)', 'color:#888');
                console.log(Object.keys(linha));
                console.groupEnd();
            }

            const keysNormMap = {}; // normKey -> originalKey
            Object.keys(linha).forEach(k => { keysNormMap[normalizarChave(k)] = k; });

            function findValue(patterns) {
                const pats = patterns.map(p => normalizarChave(p));
                for (const norm in keysNormMap) {
                    for (const p of pats) {
                        if (norm === p || norm.includes(p)) return linha[keysNormMap[norm]];
                    }
                }
                return undefined;
            }

            // Detectar se formato é "duas equipes na mesma linha" (colunas específicas) ou "uma aliança por linha"
            const temEquipe1 = findValue(['equipe 1', 'eq1', 'time 1']) !== undefined;
            const temEquipe2 = findValue(['equipe 2', 'eq2', 'time 2']) !== undefined;

            let equipe1, equipe2;

            if (temEquipe1 || temEquipe2) {
                // Formato antigo: duas equipes na mesma linha
                equipe1 = {
                    nome: findValue(['equipe 1', 'eq1', 'time 1']),
                    pN1: Number(findValue(['pontos n1 equipe1', 'n1 equipe1', 'n1 eq1', 'pontosn1equipe1', 'n1 1']) || 0),
                    pN2: Number(findValue(['pontos n2 equipe1', 'n2 equipe1', 'n2 eq1', 'pontosn2equipe1', 'n2 1']) || 0),
                    pN3: Number(findValue(['pontos n3 equipe1', 'n3 equipe1', 'n3 eq1', 'pontosn3equipe1', 'n3 1']) || 0),
                    pMov: Number(findValue(['pontos mov equipe1', 'mov equipe1', 'mov eq1', 'pontosmovequipe1', 'mov 1', 'pontos movimentacao equipe1']) || 0)
                }; equipe1.total = equipe1.pN1 + equipe1.pN2 + equipe1.pN3 + equipe1.pMov;
                equipe2 = {
                    nome: findValue(['equipe 2', 'eq2', 'time 2']),
                    pN1: Number(findValue(['pontos n1 equipe2', 'n1 equipe2', 'n1 eq2', 'pontosn1equipe2', 'n1 2']) || 0),
                    pN2: Number(findValue(['pontos n2 equipe2', 'n2 equipe2', 'n2 eq2', 'pontosn2equipe2', 'n2 2']) || 0),
                    pN3: Number(findValue(['pontos n3 equipe2', 'n3 equipe2', 'n3 eq2', 'pontosn3equipe2', 'n3 2']) || 0),
                    pMov: Number(findValue(['pontos mov equipe2', 'mov equipe2', 'mov eq2', 'pontosmovequipe2', 'mov 2', 'pontos movimentacao equipe2']) || 0)
                }; equipe2.total = equipe2.pN1 + equipe2.pN2 + equipe2.pN3 + equipe2.pMov;
            } else {
                // Formato novo: uma aliança por linha (sem separar duas equipes). Usamos a mesma estrutura duplicada.
                const pN1 = Number(findValue(['pontos n1', 'n1']) || 0);
                const pN2 = Number(findValue(['pontos n2', 'n2']) || 0);
                const pN3 = Number(findValue(['pontos n3', 'n3']) || 0);
                const pMov = Number(findValue(['pontos mov', 'mov', 'movimentacao']) || 0);
                const total = pN1 + pN2 + pN3 + pMov;
                equipe1 = { nome: '', pN1, pN2, pN3, pMov, total };
                equipe2 = { nome: '', pN1: 0, pN2: 0, pN3: 0, pMov: 0, total: 0 }; // mantém layout
            }

            let pontosAlianca = Number(findValue(['pontos alianca', 'pontuacao alianca', 'pontos da alianca']) || 0);
            if (!pontosAlianca) {
                // fallback: soma dos totais das equipes se existir formato 2 equipes
                const soma = (equipe1?.total || 0) + (equipe2?.total || 0);
                if (soma > 0) pontosAlianca = soma;
            }
            const nomeAlianca = findValue(['alianca', 'aliança']);
            return { nomeAlianca, pontosAlianca, equipe1, equipe2 };
        }

        function destacarVencedor() {
            const pv = Number(document.getElementById('pontosVermelho').textContent) || 0;
            const pa = Number(document.getElementById('pontosAzul').textContent) || 0;
            const cardV = document.getElementById('cardVermelho');
            const cardA = document.getElementById('cardAzul');
            cardV.classList.remove('border', 'border-4', 'border-warning', 'shadow-lg');
            cardA.classList.remove('border', 'border-4', 'border-warning', 'shadow-lg');
            if (pv === pa) return; // empate não destaca
            const winnerCard = pv > pa ? cardV : cardA;
            winnerCard.classList.add('border', 'border-4', 'border-warning', 'shadow-lg');
        }

        function aplicarResultadosOficiais() {
            if (!dadosOficiais.length) return;
            const norm = s => normalizarChave(s || '');
            const idx = {};
            dadosOficiais.forEach(r => {
                const num = getValorFlex(r, 'Numero do jogo') || r['numeroJogo'] || r['Número do jogo'];
                const alianca = getValorFlex(r, 'Alianca') || getValorFlex(r, 'Aliança') || r['Alianca'] || r['Aliança'];
                let pontos = getValorFlex(r, 'Pontos Alianca') || getValorFlex(r, 'Pontuacao Alianca') || r['Pontos Alianca'];
                if (!num || !alianca) return;
                pontos = Number(pontos || 0);
                (idx[num] || (idx[num] = {}))[norm(alianca)] = pontos;
            });
            matchesElim.forEach(m => {
                if (!m.numeroJogo) return; const bucket = idx[m.numeroJogo]; if (!bucket) return;
                const aKey = norm(m.aliancaA?.nomeAlianca); const bKey = norm(m.aliancaB?.nomeAlianca); let mudou = false;
                if (bucket[aKey] !== undefined) { m.aliancaA.pontosAlianca = bucket[aKey]; mudou = true; }
                if (bucket[bKey] !== undefined) { m.aliancaB.pontosAlianca = bucket[bKey]; mudou = true; }
                if (mudou) m.oficial = true;
            });
        }

        function mostrarResultado(idMatch) {
            const match = matchesElim.find(m => m.idMatch === idMatch);
            if (!match) { statusMsg.textContent = 'Confronto não encontrado.'; return; }
            const nomeA = match.aliancaA?.nomeAlianca || 'Aliança A';
            const nomeB = match.aliancaB?.nomeAlianca || 'Aliança B';
            document.getElementById('nomeEquipeVermelha').textContent = match.oficial ? nomeA + ' (oficial)' : nomeA;
            document.getElementById('nomeEquipeAzul').textContent = match.oficial ? nomeB + ' (oficial)' : nomeB;
            document.getElementById('pontosVermelho').textContent = match.aliancaA?.pontosAlianca ?? 0;
            document.getElementById('pontosAzul').textContent = match.aliancaB?.pontosAlianca ?? 0;
            renderAllianceMetrics('metricsVermelho', match.aliancaA);
            renderAllianceMetrics('metricsAzul', match.aliancaB);
            destacarVencedor();
            statusMsg.textContent = match.oficial ? 'Pontuação oficial aplicada.' : '';
        }

        btnBuscar.addEventListener('click', () => {
            const num = selectJogo.value;
            if (!num) { statusMsg.textContent = 'Selecione um confronto.'; return; }
            statusMsg.textContent = '';
            mostrarResultado(num);
        });

        // Carrega eliminatórias ao iniciar
        carregarJogosElim();
    </script>
</body>

</html>